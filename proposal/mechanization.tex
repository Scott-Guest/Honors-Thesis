\section{Mechanization}\label{sec:mechanization}
To round off our proposed development, we also seek to ensure its correctness by proving various metatheoretical and semantic theorems. However, as discussed, pattern matching with holes in both expressions and patterns can be quite intricate, requiring reasoning about a three-valued logic of must, must not, and indeterminate judgments. Thus, even with on-paper proofs showing that such a system is correct, it can be difficult to have full confidence that all possibilities have been considered. Anecdotally, the current in-progress work on this system already contains some 150+ pages of tediously typed out proofs, and is likely to contain at least a few mistakes. To address this, we plan to mechanize the semantics and metatheory of our calculus in the Agda proof-assistant.

Briefly, Agda is a dependently typed functional programming language based on a variant of Martin-L\"of type theory known as the Unified Theory of Dependent Types \cite{DBLP:books/daglib/0078470, norell:thesis}. With dependent types, the division between types and values becomes blurry - types may be parameterized by arbitrary values, and types may be given as an argument or result of functions. Moreover, through the well-known Curry-Howard correspondence aka "types as propositions", a type $T$ may be considered as equivalent to the proposition "$T$ is inhabited". By designing appropriate datatypes, types may then encode mathematical statements, and constructing an Agda term of that type provides proof of the statement's correctness. Using this approach, we plan to verify all major theorems required to ensure our systems correctness.