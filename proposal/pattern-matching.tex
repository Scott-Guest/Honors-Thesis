\section{Pattern Matching with Typed Holes}

Let us begin by reviewing pattern matching in the context of languages without holes. Such a feature should be familiar to many modern developers, as it has seen widespread adoption in typed functional languages such as OCaml \cite{leroy:hal-00930213}, Haskell \cite{marlow2010haskell}, and Elm \cite{Elm}, and more recently, has also been implemented to varying degree in mainstream imperative languages including Rust \cite{10.5555/3271463} and Python \cite{pep634}, and has been proposed for a future version of C++ \cite{murzin2019pattern}.

At a high-level, pattern matching allows one to conditionally branch based on the "shape" of a piece of data, while simultaneously binding sub-terms of the data to given variable names. For example, consider \todo{insert figure, discuss figure}. 

More than just a useful control flow structure, pattern matching also helps to ensure program correctness. For example, consider a program which check if an input falls into various cases, performing different actions in each case. When the cases are not entirely disjoint, the order that these checks are performed may be crucial, and if a later collaborator reorders them, it can introduce subtle bugs. However, if we formulate this program using pattern matching, then many such bugs can be prevented through \emph{redundancy analysis}. The compiler can statically guarantee that every pattern


By performing \emph{exhaustiveness analysis}, one can also statically check that every expression of a given type matches at least one of the patterns in a \li{match} expression. As a result, the programmer is forced to handle every possible form of an input, and if they fail to do so, the language can often assist them by generating expressions which are not yet handled \cite{Harper2012}.\todo{maybe reference figure}. With this, large classes of bugs can be prevented statically. For example, from a certain viewpoint, common security issues such as null-pointer exceptions can be viewed as a failure to check exhaustiveness. Exhaustiveness also aids refactoring: if a datatype is extended with additional constructors, then a language can statically identify every location where these additional constructors must be handled. 

Anecdotally, the author's found these analyses immensely useful during the development of the Agda mechanization discussed in \autoref{sec:mechanization}. In the context of Agda and other dependently typed theorem provers, exhaustiveness is used to ensure totality, e.g. guaranteeing that every proof handles all necessary cases. When, for example, we added a unit type to Peanut after an initial mechanization had already been completed, this removed the need to manually track down and identify all proofs with missing cases. Instead, all that was necessary was handle every non-exhaustiveness error reported by the compiler one-by-one.

Let us now return to languages with holes, considering how we can implement pattern matching while maintaining the maximal liveness invariant. Presently, all current systems only support holes in expressions or types, but not in binding constructs. Thus, when editing a pattern itself, intermediate states are not well-formed terms, and they cannot be given static or dynamic meaning. To correct this, we must extend our notion of holes to also include \emph{pattern holes}. Analogously to expression holes, we include two variants. \emph{Empty pattern holes} indicate a missing sub-term of a pattern. \emph{Non-empty pattern holes} surround patterns that may be ill-typed with regards to their location in a larger pattern. With this, we can indeed represent any intermediate pattern edit state, but the question remains of what static and dynamic semantics can be given to these pattern holes.

Consider the case of a pattern expression \todo{insert figure, discuss figure}. Thus, when we allow pattern holes, we can no longer determinately say whether an expression matches a given pattern. That is, what once a binary decision - either $e$ matches $p$ or $e$ does not match $p$ - is now a ternary decision: either $e$ definitely matches $p$, $e$ definitely does not match $p$, or $e$ may or may not match $p$ depending on how the various holes are filled. As a result, the analyses we perform are also ternary decisions: a \li{match} expression may either be definitely exhaustive, definitely nonexhaustive, or indeterminate, and likewise for redundancy.

The above identifies the main contributions our proposal will make. We seek to develop a calculus which will allow pattern matching with these holes, identifying when a match is indeterminate and when an expression can no longer be evaluated without further hole-filling. As well, we will develop a means to statically perform the possibly indeterminate exhaustiveness and redundancy checking described above.