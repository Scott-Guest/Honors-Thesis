\section{Peanut: A Typed Pattern Hole Calculus}\label{sec:peanut}
We now formalize the high-level discussion described in \autoref{sec:pattern-matching}. While all of our work has been implemented into the full Hazel system, for ease of presentation, we distill our contribution into a bare-bones typed lambda calculus called Peanut. The core of our calculus is based upon the Hazelnut Live internal language \cite{DBLP:journals/pacmpl/OmarVCH19}, but extended to include pattern holes. We develop a dynamic semantics which allows live evaluation as discussed in \autoref{sec:live-eval}, and additionally, present a static semantic guaranteeing exhaustiveness and irredundancy as discussed in \autoref{sec:exhaustiveness} and \autoref{sec:redundancy}. 

We begin in \autoref{sec:syntax} by presenting the syntax of our calculus. In \autoref{sec:dynamics}, we then provide a small-step dynamic semantics with support for evaluating incomplete programs. In \autoref{sec:constraints}, \autoref{sec:statics}, and \autoref{sec:analyses}, we give the corresponding static semantics as a system of type assignment, making use a constraint language to reason about exhaustiveness and irredundancy. We defer discussion of decidability and implementation until \autoref{sec:decidability}.

\subsection{Syntax}\label{sec:syntax}
\input{fig-syntax}
\input{fig-pointer-erasure}

Figure \ref{fig:syntax} presents the syntax of Peanut. Peanut closely mirrors the internal language of Hazelnut Live \cite{DBLP:journals/pacmpl/OmarVCH19}, a typed lambda calculus with expression holes which provides the base of the Hazel system. For ease of presentation, we attempt to include only those forms necessary to have a rich discussion of pattern matching. Resultingly, we remove most of the machinery related to gradual typing \cite{DBLP:conf/snapl/SiekVCB15}, but such an extension is fairly straightforward to implement. Most of the forms are standard, and we follow their formulations outlined in \cite{Harper2012}. 

Unsurprisingly, we include lambda functions and function application. We choose natural numbers as our base type. In order to create interesting expressions to pattern match on, we also allow the formation of binary sum and binary product types. Correspondingly, we include pairs, projection operators, and left and right injections. (Note that pattern matching generally negates the need for explicit projections operators, but we include such forms here for reasons discussed later.) To simplify our type assignment system, we also require injections and functions to have explicit type annotations. Such annotations are fairly innocuous, as Peanut represents an internal language, so if desired, annotations can always be inserted during elaboration. Finally, we include the main forms of interest: holes, patterns, and match expressions.

As discussed in \autoref{sec:intro}, holes come in two variants. Empty expression holes are written $\hehole{u}$ and indicate missing syntactic pieces, while non-empty holes expression holes are written $\hhole{e}{u}$ and act as a membrane around a type inconsistency at the expression $e$. Analogously, empty pattern holes are written $\heholep{w}$ and indicate missing sub-terms of a pattern, while non-empty pattern holes are written $\hholep{p}{w}{\tau}$ and surround a type-inconsistency, with $\tau$ recording the type of $p$. Here, the labels $u$ and $w$ are identifiers for the corresponding hole. As Peanut represents an internal language, distinct identifiers should correspond to distinct holes in the original program. However, as evaluation can lead to holes being replicated during substitution, we do not enforce a uniqueness constraint within Peanut itself.

Outside of holes, patterns also include a form corresponding to each constructor for values, variables, and a wildcard pattern $(\_)$. Semantically, the wildcard is matched by any expression, allowing the user to indicate a default case. Match expressions $\hmatch{e}{\zrules}$ then consist of a scrutinee $e$ and a list of rules $\zrules$. As we wish to allow live evaluation, we must be able to represent intermediate execution states of the match expression. Correspondingly, the list $\zrules$ is zippered \cite{DBLP:journals/jfp/Huet97}, effectively containing a pointer to the current rule under consideration. Syntactically, this is given by a triple, $\zruls{rs_{pre}}{r}{rs_{post}}$, with a prefix list of rules already considered, $rs_{pre}$, the current rule, $r$, and a suffix list of rules yet to be considered, $rs_{post}$ . We can erase this pointer through the pointer erasure operator, $\rmpointer{\zrules}$, as defined in \autoref{fig:pointer-eraser}, yielding an unzippered list. Each rule is of the form $\hrul{p}{e}$, where $p$ is a pattern and $er$ is the corresponding branch expression. 

\subsection{Dynamic Semantics}\label{sec:dynamics}

\input{fig-step}
\input{fig-final}

Dynamically, Peanut seeks to extend Hazelnut Live \cite{DBLP:journals/pacmpl/OmarVCH19} while maintaining the ability to evaluate "around" expressions with holes. That is, upon encountering a hole, Peanut should delay its evaluation as long as possible, then proceed to take all other evaluation steps which do not rely on the eventual contents of the hole. For all non-pattern matching forms, our rules correspond exactly to the rules of Hazelnut Live, albeit, formulated as a small-step operational semantics rather than a contextual one. \autoref{fig:step} displays this stepping judgement $\htrans{e}{e'}$, indicating that evaluating an expression $e$ one step yields the expression $e^\prime$.

To begin, consider how one typically evaluates, say, a function application $\hap{e}{e^\prime}$ in a strict language without holes. Initially, the function $e$ is stepped as far as possible, continuing until it is reduced to a value. Next, evaluation steps the argument $e^\prime$, again continuing until it is reduced to a value. Once all these reductions have occurred, only then is an actual substitution applied. Notably, the key ingredient to this process is the ability to detect when an expression has been reduced "as far as possible", or equivalently, when an expression has been reduced to a value. 

In the presence of pattern and expression holes, evaluation proceeds in much the same way. \autoref{fig:final} defines a judgement $\isFinal{e}$ indicating when an expression $e$ is \emph{final}, i.e when no further evaluation steps can occur. The rules \ITApFun, \ITApArg, and \ITAp are then the same as we described in our example. Crucially, however, holes extend the notion of finality to include not just values, but \emph{indeterminate} forms as well. That is, there are terms which have indeed been reduced as far as possible, but they still contain holes in the end result, and they will require further evaluation if such holes are filled at a later point in time. We differentiate between these cases with the judgement $\isVal{e}$, characterizing values, and the judgement $\isIndet{e}$, characterizing indeterminate expressions. Correspondingly, the $\isFinal{e}$ judgement is given as a disjunction of these two cases.

For Peanut, the main task is to describe the behavior of a match expression $\hmatch{e}{\zrules}$. First, as described by \ITExpMatch, we step the scrutinee $e$, eventually yielding either a value or indeterminate form. Once $e$ is final, we then proceed to pattern match, comparing $e$ to each pattern sequentially from the top down. If $e$ indeed matches a pattern, then we step to the corresponding branch expression as in the conclusion of \ITSuccMatch. Instead, if $e$ does not match the pattern as in \ITFailMatch, then we move to consider the next rule, using the pointer erasure operator of \autoref{fig:pointer-eraser} to increment the zipper. Note that, per our previous discussion, an expression may also indeterminately match a pattern. The \IMatch rule in the $\isIndet{e}$ judgement covers this case, indicating that we cannot safely proceed past an indeterminate pattern match, leading to the entire match expression being indeterminate without further hole-filling.

Our stepping and finality judgements indeed cover all possible cases. The following theorem states this, combining progress and determinism. Here, the judgement $\hexptyp{\cdot}{\Delta}{e}{\tau}$ indicates that $e$ is a closed term of type $\tau$, as discussed further in \autoref{sec:statics} when presenting Peanut's static semantics.

\begin{theorem}[Deterministic Progress]
	\label{theorem:determinism}
	If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ then exactly one of the following holds
	\begin{enumerate}
		\item $\isVal{e}$
		\item $\isIndet{e}$
		\item $\htrans{e}{e'}$ for some unique $e'$
	\end{enumerate}
\end{theorem}

Essential to the aforementioned rules are the judgements determining whether an expression $e$ must match, must not match, or indeterminately matches a pattern $p$. \autoref{fig:patmatch} presents these three cases. First, the judgement $\hpatmatch{e}{p}{\theta}$ indicates that $e$ successfully matches $p$, emitting a series of corresponding substitutions $\theta$ for the variables bound in $p$. Next, the judgement $\hnotmatch{e}{p}$ indicates that $e$ does not match $p$. Finally, the judgement $\hmaymatch{e}{p}$ indicates that $e$ indeterminately matches $p$ depending on the eventual contents of holes in $e$ or $p$. These judgements correspond respectively to the rules \ITSuccMatch, \ITFailMatch, and \IMatch discussed above, appearing as a premise in each.

As desired, these three matching judgements are exclusive and cover all possible cases. Again, the judgement $\hexptyp{\cdot}{\Delta}{e}{\tau}$ states that $e$ is a closed term of type $\tau$, while the judgement $\hpattyp{p}{\tau}{\Gamma}{\Delta}$ indicates that we can also assign the type $\tau$ to our pattern $p$. Note that because of the correspondence between these matching judgements and the semantics of the match expression, the following lemma encapsulates the majority of the work required to prove $\autoref{theorem:determinism}$.

\begin{lemma}[Matching Determinism]
	\label{lemma:match-determinism}
	If $\isFinal{e}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta}$ then exactly one of the following holds
	\begin{enumerate}
		\item $\hpatmatch{e}{p}{\theta}$ for some $\theta$
		\item $\hmaymatch{e}{p}$
		\item $\hnotmatch{e}{p}$
	\end{enumerate}
\end{lemma}

\input{fig-patmatch}
\input{fig-notintro}
\input{fig-refutable}

Let us now explore these pattern matching judgements in more depth, considering matching an expression $e$ against a pattern $p$. Note that semantics of our expression guarantees that we only perform pattern matching on well-typed and final scrutinees (per the inclusion of $\isFinal{e}$ as a premise to \ITSuccMatch and \ITFailMatch). Throughout this discussion, we then assume $e$ is final and that $e$ and $p$ are of the same type.

If we ignore cases of indeterminacy, most of the rules are fairly straightforward. For the judgement $\hpatmatch{e}{p}{\theta}$, each rule specifies that $e$ and $p$ have the same outermost constructor, and that their corresponding subterms match inductively. Conversely, the rules for $\hnotmatch{e}{p}$ identify a cases where either the outermost constructors of $e$ and $p$ mismatch (e.g. \NMInl and \NMInr), or where their outermost constructors agree, but some corresponding subterm inductively fails to match (e.g. \NMPairL and \NMPairR).

To reason about indeterminacy, however, we require a few auxillary judgements. As our scrutinee is final, it will be indeterminate if and only if it is not a value. \autoref{fig:notintro} defines a judgement $\notIntro{e}$ which characterizes this case, syntactically analyzing the outermost constructor of $e$ to determine that it cannot be a value. Note that an indeterminate $e$ will be further evaluated after hole filling, so correspondingly, our rules should treat such an $e$ as opaque, never inspecting any of its subterms. However, even with this restriction, there are still cases where $e$ must match a pattern $p$. That is, a pattern $p$ could be irrefutable in the sense that it must be matched by all expressions of the same type, say, if it is a variable \li{x} or wildcard $\_$. Correspondingly, \autoref{fig:refutable} defines a judgement $\refutable{p}$ indicating that $p$ is not irrefutable, i.e. there is some hole filling which allows at least one expression to fail to match $p$.

Together, the combinations of these judgements allows us to identify all indeterminate matches. The rule \MMNotIntro gives that a match is indeterminate whenever $e$ is indeterminate and $p$ is not irrefutable. The rules \MMEHole and \MMHole state that directly matching against a hole will always be indeterminate. All other indeterminacy arises inductively from some subterms indeterminately matching. Conversely, even in the case when $e$ is indeterminate, we wish to have $e$ match an irrefutable pattern $p$. The rules \MVar and \MWild give two explicit cases of this. In \MNotIntroPair, the irrefutability is implicit - a term $\hfst{e}$ or $\hsnd{e}$ can only match an irrefutable pattern, but we explicitly derive the matching judgements in order to emit appropriate substitutions

\subsection{Match Constraint Language}\label{sec:constraints}
With the dynamic semantics of Peanut defined, we now turn to the problem of statically reasoning about the runtime behavior of our programs. In particular, we focus on ensuring exhaustiveness and redundancy of match expressions. Towards this end, we extend an idea outlined in \cite{Harper2012} by introducing a \emph{match constraint language}. Intuitively, such a language encodes the logic of patterns, with each constraint corresponding to the restriction that a pattern puts on those expression matching it. Further, additional constraints are added to allow taking negation, logical and ($\land$), and logical or ($\lor$). In \autoref{sec:statics}, we explicitly describe how constraints are generated by patterns. In \autoref{sec:analyses}, we then describe how constraints enable static reasoning about exhaustiveness and irredundancy.

\input{fig-constraint}

The syntax of the constraint language is displayed in \autoref{fig:constraint}. Note that each pattern indeed has a corresponding constraint of the same syntactic form. The only exception here is that variables and wildcards both map to the truth constraint ($\ctruth$), as they are both matched by any expression. We specify that a constraint $\xi$ restricts expressions of type $\tau$ with the constraint type assignment judgement $\ctyp{\xi}{\tau}$. Ignoring indeterminacy and $\cunknown$ for now, one can explicitly model constraints of type $\tau$ as the Boolean algebra formed by subsets of the set of all final expressions of type $\tau$. That is, a constraint $\ctyp{\xi}{\tau}$ can be interpreted as the set of all final expressions of type $\tau$ which \emph{satisfy} $\xi$. Correspondingly, the \emph{dual} of $\xi$ , written $\cdual{\xi}$, is satisfied by all appropriately-typed final expressions not satisfying $\xi$, and thus can be interpreted as the complement of the set identified by $\xi$. The truth constraint $\ctruth$ and falsity constraint $\cfalsity$ are intrepreted as the whole set and the empty set respectively. Up to equivalence, the usual laws of Boolean logic hold, e.g. the dual of $\cdual{\xi}$ should be equivalent to $\xi$.

\input{fig-satisfy}

Just as we introduced pattern holes into patterns, we include an unknown constraint $(\cunknown)$ in our constraint language to represent indeterminacy. Correspondingly, we have analogs of the three pattern matching judgements - for a final expression $e$ and constraint $\xi$ of the same type, either $e$ \emph{must satisfiy} $\xi$, $e$ \emph{must not satisfy} $\xi$, or $e$ \emph{indeterminately satisfies} $\xi$ due to the presence of holes or the unknown constraint. \autoref{fig:satisfy} explicitly defines these judgements. The judgement $\csatisfy{e}{\xi}$ specifies that $e$ satisfies $\xi$, the judgement $\cmaysatisfy{e}{\xi}$ specifies that $e$ may satisfy $\xi$, and the judgement $\csatisfyormay{e}{\xi}$ provides the disjunction of these two cases. Note that we do not include a corresponding "$e$ does not satisfy $\xi$" judgement, but rather reason about the non-derivability of $\csatisfyormay{e}{\xi}$.

The rules for each of satistfaction judgements almost exactly mirror the corresponding rules for the pattern matching judgements. The only notable exception is the rules \MMNotIntro and \CMSNotIntro. Recall that \MMNotIntro captures the notion that an indeterminate expression $e$ should indeterminately match a pattern $p$, excluding the edge case where $p$ is matched by all expressions. While \CMSNotIntro captures this same notion, it additionally must consider the edge case where a constraint $\xi$ is impossible to match at all. With patterns, this is not a concern, as every pattern is matchable by at least one expression. To accomplish this, the $\possible{\xi}$ judgement defined in \autoref{fig:xi-possible} specifies that $\xi$ is possibly satisfied by at least one expression, i.e. it is not equivalent to $\cfalsity$. We also define a $\refutable{\xi}$ judgement in \autoref{fig:xi-refutable}, which exactly corresponds to the $\refutable{p}$ judgement for patterns. 

\input{fig-xi-possible}
\input{fig-xi-refutable}

Expectedly, one can prove that there is indeed a correspondence between a pattern and its emitted constraint. The judgement $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$ indicates that a pattern $p$ emits the constraint $\xi$, but we defer a more in depth discussion until \autoref{sec:statics}.

\begin{lemma}[Matching Coherence of Constraint]
	\label{lemma:const-matching-coherence}
	Suppose that $\hexptyp{\cdot}{\Delta_e}{e}{\tau}$ and $\isFinal{e}$ and $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$. Then we have
	\begin{enumerate}
		\item $\csatisfy{e}{\xi}$ iff $\hpatmatch{e}{p}{\theta}$
		\item $\cmaysatisfy{e}{\xi}$ iff $\hmaymatch{e}{p}$
		\item $\cnotsatisfyormay{e}{\xi}$ iff $\hnotmatch{e}{p}$
	\end{enumerate}
\end{lemma}
 
Combining this result \autoref{lemma:match-determinism}, we may also verify that the various constraint satisfaction judgements are mutually exclusive and cover all possibilities.

\begin{theorem}[Exclusiveness of Constraint Satisfaction]
	\label{theorem:exclusive-constraint-satisfaction}
	If $\ctyp{\xi}{\tau}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ then exactly one of the following holds
	\begin{enumerate}
		\item $\csatisfy{e}{\xi}$
		\item $\cmaysatisfy{e}{\xi}$
		\item $\cnotsatisfyormay{e}{\xi}$
	\end{enumerate}
\end{theorem}

With the setup of our constraint language clear, let us return to the issue of redundancy and exhaustiveness checking. For now, we focus only on defining these notions in terms of constraints, deferring discussion of their actual implementation until \autoref{sec:decidability}.

Consider if we have a zippered list of rules $\zruls{rs_{pre}}{r}{rs_{post}}$ with the currently considered rule $r$ given by $\hrul{p}{er}$. Recalling the discussion in \autoref{sec:redundancy}, we state that $r$ is redundant if it is unreachable in any hole filling, i.e. if any expression which could possibly reach $r$ will instead match against one of the rules in $rs_{pre}$. Stated formally, $r$ will be redundant if for all appropriately-typed final expressions $e$, if either $\hpatmatch{e}{p}{\theta}$ or $\hmaymatch{e}{p}$ is derivable then so is $\hpatmatch{e}{p^\prime}{\theta^\prime}$ for some pattern $p^\prime$ in a previous rule. Using \autoref{lemma:const-matching-coherence}, we can translate this into a statement about constraints. That is, a constraint $\xi$ is redundant if any appropriately-typed expression $e$ with $\csatisfyormay{e}{\xi}$ necessarily has $\csatisfy{e}{\xi_{pre}}$ for some constraint $\xi_{pre}$ emitted by a pattern earlier in the sequence. In fact, as we may take the logical or of constraints, we can consider just a single $\xi_{pre}$ taken as the disjunction of all previously emitted constraints. This inspires the following definition of \emph{entailment}.

\begin{definition}[Indeterminate Entailment of Constraints]
	\label{definition:const-entailment}
	Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$.
	Then $\csatisfy{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isVal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfy{e}{\xi_2}$
\end{definition}
Correspondingly, if $\xi_{pre}$ is the disjunction of all constraints emitted by the previously considered rules in a match, and if $\xi$ is the constraint emitted by the current rule, then the current rule is necessarily redundant if and only if $\csatisfy{\xi}{\xi_{pre}}$. Conversely, to ensure a rules is either necessarly or indeterminately irredundant, we must check that $\cnotsatisfy{\xi}{\xi_{pre}}$. In our yet-to-be-discussed static system, such checks are added as a premise in the rules \TOneRules and \TRules.

It is worth emphasizing that the above definition identifies \emph{necessary} redundancy rather than \emph{indeterminate} redundancy. Indeed, indeterminate redundancy may be resolved by further hole-filling, so we do not yet desire to report an error to the user. Likewise with exhaustiveness checking, we only wish to report an error in cases of \emph{necessary} inexhaustiveness. To that end, conversely, we must be able to identify when a constraint is either \emph{necessarily} exhaustive or \emph{indeterminately} exhaustive. This is captured by a slightly weaker notion of entailment.

\begin{definition}[Potential Entailment of Constraints]
	\label{definition:nn-entailment}
	Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$. Then $\csatisfyormay{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfyormay{e}{\xi_2}$ 
\end{definition}
We can then state that a constraint $\xi$ is either necessarily or indeterminately exhaustive exactly when $\csatisfyormay{\ctruth}{\xi}$, relying on the fact that every expression possibly satisfies the truth constraint $\ctruth$. That is, $\xi$ is not necessarily inexhaustive if every expression possibly satisfies $\xi$. 

Note that the definition of potential entailment quantifies over all final expressions rather than just those $e$ with $\isVal{e}$. Resultingly, so long as the constraint $\xi$ emitted by a list of rules has $\csatisfyormay{\ctruth}{\xi}$, any scrutinee, either a value or indeterminate form, will possibly match at least one of the patterns in the rule, preventing evaluation from getting stuck. Such a definition simplifies the proof of progress in \autoref{theorem:determinism}. However, as the following lemma states, exhaustiveness over values also ends up being sufficient.

\begin{lemma}
	\label{lem:val-final-satormay}
	Suppose $\ctyp{\hxi}{\tau}$. Then $\csatisfyormay{e}{\hxi}$ for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ \textbf{iff} $\csatisfyormay{e}{\hxi}$ for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isVal{e}$.
\end{lemma}

To prove this, we reason about the possible values that result when filling holes in an indeterminate expression. Formally, the judgement $\inValues{e'}{\Delta}{e}$ defined in \autoref{fig:values} indicates that $e'$ is one of the possible values of $e$ after hole-filling. Here, $\Delta$ is a hole context used for typing information, which we discuss further in \autoref{sec:statics}. Using such a judgment, \autoref{lem:val-final-satormay} follows straightforwardly from the ensuing lemma.

\begin{lemma}
	\label{lem:complete-not-satormay}
	Assume $\isFinal{e}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and
	$\ctyp{\hxi}{\tau}$. If $\cnotsatisfyormay{e}{\hxi}$, then for any $e^\prime$ with
	$\inValues{e'}{\Delta}{e}$ we also have $\cnotsatisfyormay{e'}{\hxi}$.
\end{lemma}

\input{fig-values}

\subsection{Static Semantics}\label{sec:statics}
 We are now ready to present the static semantics of Peanut, using the discussed match constraint language to enforce exhaustiveness and irredundancy of well-typed terms. Again, our type system is based on the internal language of Hazelnut Live \cite{DBLP:journals/pacmpl/OmarVCH19}, but extended to include typing of both patterns and expressions. Throughout, we use expression contexts $\Gamma$ to map variable names to types, and we use hole contexts $\Delta$ to map both expression and pattern hole names to their corresponding types.
 
 \input{fig-pat-rulestyp}
  
 \subsubsection{Typing of Rules and Emitted Constraints}
 We begin by formalizing pattern typing and the relationship between patterns and constraints. \autoref{fig:pat-rulestyp} presents three judgements specifying typing for patterns $p$, a single rule $r$, and a series of rules $rs$. All of the judgements here record the emitted constraints, and additionally, are used to enforce irredundancy.
 
 For patterns, the judgement $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$ specifies that, in the hole context $\Delta$, the pattern $p$ is assigned the type $\tau$, emits the constraint $\xi$, and makes typing assumptions about bound variables as recorded in the expression context $\Gamma$. Note that, unlike in any other of our typing judgements, the expression context $\Gamma$ is morally an output for pattern typing rather than an input. Rules \PTVar and \PTWild specify that wildcards and variables may be assigned any time, and as they may be matched by any expression, they emit only a truth constraint $\ctruth$. Rules \PTEHole and \PTHole specify that pattern holes emit the unknown constraint $?$, inductively checking that the content of a non-empty hole are also well-typed. All of these rules should be unsurprising.
 
 Once we have specified pattern typing, we can then check the type of a rule. Intuitively, a rule $\hrul{p}{e}$ if both $p$ and $e$ are well-typed, with $e$ possibly referencing the variables bound in $p$. Correspondingly, when we specify the type of $e$, we use the context $\Gamma \uplus \Gamma_p$, where $\Gamma_p$ records assumptions about the types of bound variables in $p$ as emitted by the judgement $\chpattyp{p}{\tau}{\xi}{\Gamma_p}{\Delta}$. Note that we need never extend the context $\Delta$, as we assume it to already include all expression and hole types in the original program source code. In summary then, the rule typing judgement $\chrultyp{\Gamma}{\Delta}{\hrulP{p}{e}}{\tau}{\xi}{\tau'}$ specifies that $r$ matches expressions of type $\tau$ and evaluates to a corresponding branch expression of type $\tau^\prime$, emitting constraint $\xi$.
 
 Finally, for later use in type checking match expression, we define typing for an entire sequence of rules $rs$. With the full rule sequence now available, we also are able to enforce irredundancy. Intuitively, the judgement $\chrulstyp{\Gamma}{\Delta}{\xi_{pre}}{rs}{\tau}{\xi_{rs}}{\tau'}$ states that all of the rules in $rs$ are matched by expressions of the same type $\tau$, and they all have corresponding branch expressions of the same type $\tau^\prime$. Moreover, it states that the disjunction of the all rules together emits the constraint $\xi_{rs}$, and crucially, that this emitted constraint does not entail another constraint $\xi_{pre}$. Morally, $\xi_{pre}$ is an input to the judgement which records the constraint emitted by all previously considered rules. Thus, checking that $\cnotsatisfy{\xi_{rs}}{\xi_{pre}}$ ensures irredundancy.
 
To accomplish this, the rule \TOneRules delegates to the single rule typing judgement, while also adding a premise $\cnotsatisfy{\xi_{r}}{\xi_{pre}}$ to ensure irredundancy. For the inductive case of a list $\hrules{r}{rs}$, we consider the rules one-by-one, analogously to how a match expression considers rules one-by-one from the top down. Correspondingly, the first premise of \TRules specifies that the head of the list $r$ is well-typed and irredundant with respect to $\xi_{pre}$. In turn, the second premise takes the constraint $\xi_r$ emitted by $r$, appends it the constraint $\xi_{pre}$ emitted by all previously considered rules, then inductively uses this as input when checking the tail of the list $rs$. At the same time, we record the constraint emitted by $\hrules{r}{rs}$ as $\cor{\xi_r}{\xi_{rs}}$, the disjunction of the constraint emitted by $r$ and that emitted by $rs$.

\input{fig-exptyp}

\subsubsection{Typing of Expressions}
 We are now able to present the full typing judgement for expressions. For all non-pattern matching forms, the rules are standard, with our inclusion of type annotations on functions and injections enabling a simple system of type assignment. \autoref{fig:exptyp} displays the definitions for the judgement $\hexptyp{\Gamma}{\Delta}{e}{\tau}$ indicating that an expression $e$ has type $\tau$, where the types of free variables are recorded in a context $\Gamma$, and the types of expression and pattern holes from the original source code are recorded in a context $\Delta$ (recall that Peanut is an internal language). The only rules of interest to us are those for the match expression, \TMatchZPre and \TMatchNZPre.
 
Considering the zippered rule list, \TMatchZPre represent the case where have not yet started pattern matching, and there are no previously considered rules. The first premise checks that the scrutinee is well-typed. The second premise ensures that the rules are all matchable by expressions of the same type $\tau$, and that all have branch expressions of type $\tau^\prime$. Correspondingly, as a the match expression will ultimately evaluate to one of these branch expressions, the type of the entire match is also $\tau^\prime$. Note that, because there are no previously considered rules, the second premise need only check irredundancy with respect to the constraint $\cfalsity$, which should never be entailed by any constraint $\xi$ with $\possible{\xi}$ (and in particular, any constraint emitted by a pattern).

For \TMatchNZPre, we are now considering the case where we are in the midst of pattern matching, having already considered the rules $rs_{pre}$ and currently considering the rule $r$. As pattern matching should only proceed once a scrutinee is fully evaluated, we add a premise requiring $\isFinal{e}$. Additionally, to ensure that it was valid to reach this point in the rule list, the scrutinee should not have matched any previously considered rules, hence we add a premise $\cnotsatisfyormay{e}{\xi_{pre}}$. Indeed, \autoref{lemma:const-matching-coherence} ensures this is the case. As well, we again require that the rules are well-typed, checking this piecewise - first with the previously considered rules $rs_{pre}$, then with the remaining rules $\hrules{r}{rs_{post}}$. Finally, we ensure exhaustiveness on the total emitted constraint as $\csatisfyormay{\ctruth}{\cor{\xi_{pre}}{\xi_{rest}}}$.

Thus, our system indeed ensures a term is well-typed only if it also both exhaustive and irredundant, either necessarily or indeterminately. Alternatively, one could also extract these checks as their own judgements separate from the type system, although exhaustiveness is still required to ensure progress in \autoref{theorem:determinism}. We take this alternative in our Agda mechanization, and discuss that choice further in \autoref{sec:mechanization}.

\subsubsection{Type Safety}
The type safety of Peanut is established by \autoref{theorem:determinism} and \autoref{theorem:preservation}.

\begin{theorem}[Preservation]
	\label{theorem:preservation}
	If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\htrans{e}{e'}$
	then $\hexptyp{\cdot}{\Delta}{e'}{\tau}$
\end{theorem}
While we do not enumerate them here, the proof of preservation relies on a number of small lemmas showing that our various typing and finality judgements are well-behaved with respect to substitution (in particular, when applying a substitution list $\theta$ emitted by the judgement $\hpatmatch{e}{p}{\theta}$). The details can be found in our mechanization.

\subsection{Eliminating Indeterminacy}\label{sec:analyses}
Thus far, we have managed to describe a type system encoding exhaustiveness and irredundancy using constraint entailment. However, it is quite unclear how to actually check when such entailment holds, and indeed, our definitions require quantifying over all final expressions of a given type, yielding no obvious decision procedure. As a first step towards remedying this, we now discuss how to rephrase questions of entailment so that no instances of the unknown constraint ($\cunknown$) are required. That is, we eliminate any indeterminacy.


\input{fig-truify-falsify}